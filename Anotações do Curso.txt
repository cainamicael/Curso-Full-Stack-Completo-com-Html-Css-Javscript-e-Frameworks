Conhecendo o VS Code: 

Podemos criar pastas e arquivos pelo VS Code
instalamos a extenção Code Runner e habilitar o auto save
habilitar para sempre mostrar a última execução, sem mostrar as anteriores nas settings da extenção
Duplicar A linha: alt + shift + seta para baixo
Excluir a linha: ctlr + x
Substituir a palavra ctrl + d 

JavaScript: 

Sentença de Código & Bloco de código
Sentenças:
Em analogia, as sentenças são as frases, já os blocos, os parágrafos
No JavaScript, a sentença pode ou não terminar com ; 
o ; mostra que e sentença terminou
para escrever cometários usa-se //  ou /* Para comentários de mais de uma linha */

Para mostrar na tela, o comendo é:
console.log("Teste") //Aspas duplas ou aspas simples
console.log(1) //Sem aspas
console.log(1+3) //sem aspas
console.log(a, b) //variáveis

Blocos de código:
Um bloco é definido por um par de chaves
{
    sentença;
    sentença;
}
Pode-se criar um bloco dentro do outro
{
    {
        sentenças;
    }
}
O VS Code pode suprimir os blocos
Os blocos podem ser vazios ou só com ;
Os códigos são organizados em: Pastas, arquivos, blocos e sentenças

Trabalhando com dados:
As casas decimais são separadas por . e não por virgula
Letras maiúsculas e minúsculas Importam!
var, let, const
é melhor para a saúde do programa ter mais constantes do que variáveis
O let é mais moderno e o const não se altera. Geralmente consts são em letra maiúscula, mas não tem regra
var identificador = valor ou var identificador;

variáveis: 
var nome = "Caneta"
var quantidade = 10
var preco = 6.4
var imposto = 1.5
console.log(quantidade) 
console.log(preco)
console.log(imposto)
console.log(preco+imposto)
nome = "Caneta Bic"  // Mudando o valor
console.log(nome)
//
Exemplo 2:
let preco = 19.90
let desconto = 0.4
let preco_com_desconto = preco * (1 - desconto)
console.log(preco_com_desconto)
//
Exemplo 3:
let nome = "caderno"
let categoria = "Papelaria"
console.log("Produto "+ nome + " categoria "+ categoria)

tipos:
Usamos o typeof para saber o tipo
O JavaScript não faz diferenciação entre inteiros e decimais
number, string, boolean...

Para saber o tipo:
let EstaChovendo = true // ou false
console.log(typeof EstaChovendo)
console.log(typeof "teste")

Tecnica de troca de valores:
let a = 7
let b = 94
[a, b] = [b, a] // faz a troca dos valores
console.log(a)
console.log(b)

Estrutura de dados:
Estrutura de dados != de dados
Visa organizar e administrar os dados exemplo: uma lista
FIFO: First in, first out - É como uma fila, o primeiro a entrar, é o primeiro a sair
LIFO: Lest in, First out - O último a entrar, é o primeiro a sair
Árvores: Exemplo: Os diretórios
As estruturas podem ser personalizadas

Executando JacaScript:
repl.it no navegador
JSFiddle no navegador
No console do chrome (f12) eu posso usar as bibliotecas que foram usadas no site. Ex: jQuery no site jquery.com

Tipagem fraca:
Tipagem é como a linguagem vai ligar com os tipos de dados
Tipagem fraca (ou dinâmica) quer dizer que em uma variável eu posso colocar tipos diferentes

Tipo Number:

Para passar string para number:
Number('2.0')

Para passar number para string:
media.toString()
String(2)//no lugar do 2, o número

Para passar number para string no valor binario:
media.toString(2)


Para saber se é inteiro:
Number.isInteger(variaveldonumero) // retorna true ou false

Para limitar as casas decimais:
media.toFixed(2)

Alguns cuidados com o number:

console.log(7/0) //Dá infinito
console.log('10/2') //Ele faz a operação e de fato da 5
console.log(0.1 + 0.7)//Não dá 0.8, dá 0.79999999999999
console.log(10.toString()) //dá erro pois é um numero literal, o 10 tem que está em parênteses

Usando Math:
É um objeto

Exponenciação:
Math.pow(raio, 2)//M maiúsculo. O 2 é o expoente, ou seja; ao quadrado

Tipo String:
Cadeia de carecteres
Tipos de delimitação: "",'',´´
Tratamento de strings

Mostrar a letra correspondente à posição:
const escola = 'cod3r'
escola.charAt(4) //Esse 4 é o Índice (Lembrando que o primeiro é o 0)
escola.charCodeAt(3)//Valor na tabela ask

Para saber em que posição/índice está a letra:
escola.indexOf('r')

Para imprimir do índice desejado para frente ou até antes do índice determinado:
escola.substring(1)//imprime od3r, pq imprime do 1 para frente. Inclui o 1
escola.substring(0, 3)//cod não inclui o 3

concatenar:
console.log('escola'.concat(escola).concat("!"))


Para substituir o valor de um índice REPLACE:
console.log(escola.replace(3, 'e'))// troca o índice 3 por e
console.log(escola.replace('r, 'e'))// troca a letra r por e

criar array:
'ana,maria,pedro'.split(',')// a , é o separador. o que vai indicar que vai separar as palavras para os elementos do array 

Template Strings:
Usa-se Crase

Interpolação:
const nome = 'rebeca'
const concatenacao = 'olá '+ nome +'!'
const template = `olá ${nome}!`
console.log(concatenacao, template)

Tipo Boolean:
Verdadeiro ou Falso
true ou false
0 ou 1

let isATIVO = 1
console.log(!!isATIVO) // não não (exclamações) verdadeiro

let isATIVO = 1
console.log(!isATIVO) // não (exclamações) falso

let nome = ""
console.log(nome || 'desconhecido') //retorna desconhecido

let nome = "João"
console.log(nome || 'desconhecido') //retorna João

Array:
Agrupar múltiplos valores, de modo linear. Vetor
Acessado pelo Índice
Não tem tamanho fixo. É heterogêneo
Não misture os conteúdos

Criando array:
const valores = [7.7,8.9,6.3,9.2]
console.log(valores[0],valores[3])
valores[4] = 10
console.log(valores[4])

Quantidade de elementos:
console.log(valores.length)

Excluir o último elemento:
console.log(valores.pop())

Tipo Object:
Não é a mesma coisa que json
Cria-se com {}
É uma coleção de pares chave-valor 
Quando omite a chave do objeto, o js(a partir do ecmascrypt 2015, já cria sozinho )

Criando objeto:
const prod1 = {}
prod1.nome = 'celular ultra mega'
prod1.preco = 4998.90
console.log(prod1)

exemplo 2:
prod1['Desconto legal'] = 0.40 // evitar essa forma

exemplo 3:
const prod2 = {
    nome: 'camisa polo',
    preço: 79.90
}

Null & Undefined:
Pode fazer referencia ao ponteiro ou usar o tipo primitivo
o null limpa o ponteiro
não usar o undefined, é melhor usar o null

removendo atributo:
delete produto.preco

Funções:
Pode não receber parâmetro, não ter retorno, etc.

Criando função sem retorno:
function imprimirSoma(a, b){
    console.log(a+b)
}
imprimirSoma(2, 3)

Criando função com retorno:
function soma(a, b = 0){ // se não colocar nada, o b por padrão fica 0
    return a + b
}
console.log(soma(2, 3)) // tem que ser no console para printar o valor

Armazenando uma função em uma variável:
const imprimirSoma = function(a, b){
    console.log(a+b)
}
imprimirSoma(2, 3)

Armazenando uma função arrow em uma variável:
const soma = (a,b) => {
    return a+b
}
console.log(soma(2,3))

Função de sorteio:
function getInteiroAleatorioEntre(min, max){
    const valor = Math.random() * (max - min) + min
    return Math.floor(valor)
}


Retorno implícito:
const subtracao = (a, b) => a-b
console.log(subtracao(5,3))

exemplo 2:
const imprimir2 = a => console.log(a)
imprimir2('Legall')

Var:
FUJA DO ESCOPO GLOBAL
A variável var mesmo dentro de um bloco, ficará visível fora do bloco(Excerto função)
Vai para o escopo global
Ou é global ou é no escopo de função

Let:
Escopo global,escopo de função e escopo de bloco

Var em loop:
for (var i = 0; i < 10; i++){
    console.log(i)
}
console.log('i = ', i)//ele imprime 10

exemplo 2:
const funcs = []
for (var i = 0; i < 10; i++){
    funcs.push(function(){
        console.log(i)
    })
}
funcs[2]()
funcs[8]()


Let em loop:
for (let i = 0; i < 10; i++){
    console.log(i)
}
console.log('i = ', i)//da erro

exemplo 2:
const funcs = []
for (let i = 0; i < 10; i++){
    funcs.push(function(){
        console.log(i)
    })
}
funcs[2]()
funcs[8]()

Hoisting:
Içar
Quando usa o var, pode ocorrer o hoisting
console.log('a = ', a)
var a = 2
console.log('a = ', a)
ele não da erro
var a
console.log('a = ', a)
a = 2
console.log('a = ', a)
ele implicitamente fez isso

Par nome/valor:
Contexto léxico 1 é em que local físico do código o par chave/valor foi definido

Operadores:
Atribuição - Sempre o símbolo da atribuição vem antes

Atribuição aditiva:
b += a // b = b + a

Atribuição subtrativa:
b -= 4 // b = b - 4 

Atribuição multiplicativa:
b *= 2 // b = b * 2

Atribuição divisiva:
b /= 2 // b = b / 2

Atribuição modular:
b %= 2 // b = b % 2

Destructuring - Desestruturação; Tira algum elemento da estrutura
no objeto usa {} e no array usa []
const pessoa = {
    nome: 'ana',
    idade: 5,
    endereco: {
        logradouro: 'rua abc',
        numero: 1000
    }
}

Extraindo os atributos do objeto:
const {nome, idade} = pessoa
console.log(nome, idade)

Colocando os atributos do objeto extraídos em variáveis:
const{nome: n,idade: i} = pessoa
console.log(n, i)

Objeto do objeto:
const { endereco: {logradouro,numero}} = pessoa
console.log(logradouro, numero)

Desestruturação de array:
const [a] = [10]
console.log(a)

exemplo 2:
const [n1, ,n3, ,n5,n6 = 0] = [10, 7, 9, 8]
console.log(n1, n3, n5, n6)

Destructuring em função com objeto como parâmetro:
function rand({min = 0, max = 1000}){
    const valor = Math.random() * (max-min) + min
    return Math.floor(valor)
}
console.log(rand({max: 50, min: 40}))
console.log(rand({min: 955}))
console.log(rand({}))

Destructuring em função com array como parâmetro:
function rand([min = 0, max = 1000]){
    if (min>max) [min,max] = [max, min]
    const valor = Math.random() * (max - min) + min
    return Math.floor(valor) 
}
console.log(rand([50, 40]))
console.log(rand([155]))
console.log(rand([,10]))
console.log(rand([]))

Aritméticos:
Operam em cima de 2 operandos
+, -, *, /, %

Relacionais:
Sempre será verdadeiro ou falso
== igual
=== extritamente igual // leva o tipo também em consideração
!= diferente

Lógicos:
e, ou, ou exclusivo, não
ou exclusivo
v xor v = f
v xor f = v
f xor v = v
f xor f = f
&&, ||, !=, !
Quando omite a chave do objeto, o js(a partir do ecmascrypt 2015, já cria sozinho )

Operadores lógicos e função, com objeto:
function compras(trabalho1 , trabalho2){
    const comprarSorvete = trabalho1 || trabalho2 // ou
    const comprarTv50 = trabalho1 && trabalho2 //e
    const comprarTv32 = !!(trabalho1 ^ trabalho2)
    //const comprarTv32 = !!(trabalho1 ^ trabalho2) //ou exclusivo
    const comprarTv32 = trabalho1 != trabalho2 //ou exclusivo
    const manterSaudavel = !comprarSorvete // operador unário
    return {comprarSorvete, comprarTv50, comprarTv32, manterSaudavel}
}
console.log(compras(true, true))
console.log(compras(true, false))
console.log(compras(false, true))
console.log(compras(false, false))

Unários:
++numero1 // ordem de precedência maior | soma 1 numero
--numero1 // ordem de precedência maior | subtrai 1 numero
numero1++
numero1--
console.log(++num1 === num2--) // da true, por causa da localização dos operadores | não colocar incremento em comparações

Ternário:
Três operandos
Pode equivaler a condicionais
? 'opçãoo 1 se for verdadeiro' : 'opção 2 se for fácil'

Operador ternário em função Arrow:
const resultado = nota => nota >= 7 ? 'Aprovado' : 'Reprovado'
console.log(resultado(7.1))
console.log(resultado(6.1))

Tratamento de erros:
Try/Catch/throw/finally
function tratarErroELancar(erro){
    //throw new erro('...')
    //throw 10
    //throw true
    //throw 'mensagem'
    throw {
        nome: erro.name,
        msg: erro.message
    }
}
function imprimirNomeGritado(obj){
    try {
        console.log(obj.name.toUpperCase() + '!!!')    
    }catch (e) {
        tratarErroELancar(e)
    }finally{
        console.log('final')
    }
}

const obj = {nome: 'roberto'}
imprimirNomeGritado(obj)
try é um bloco que pode gerar erro, que pode ser tratado por um catch, e por último executa o finally

Estruturas de Controle:
Condicionais:
If, else
Se for só uma sentença de código, não precisa colocar {}
Não usar ;

If:
if(nota >= 7){
        console.log('Aprovado!')        
    }

Exemplos que dão falso, por isso, não fazem nada:
function seForVerdadeEuFalo(valor){
    if(valor){
        console.log('É verdade...'+ valor)
    }
}
seForVerdadeEuFalo() //não printa
seForVerdadeEuFalo(null) //não printa
seForVerdadeEuFalo(undefined) //não printa
seForVerdadeEuFalo(NaN) //não printa
seForVerdadeEuFalo('') //não printa
seForVerdadeEuFalo(0) //não printa

If/Else:
const imprimirResultado = function(nota){
    if(nota >= 7){
        console.log('Aprovado!')
    }else{
        console.log('Reprovado!')
    }
} 
imprimirResultado(10)
imprimirResultado(4)
imprimirResultado('epa') // Cuidado, como dá falso, ele coloca como reprovado

If/Else if:
Number.prototype.entre = function (inicio, fim){
    return this >= inicio && this <= fim
}
const impromirResultado = function(nota){
    if(nota.entre(9, 10)){
        console.log('quadro de honra!')
    }else if(nota.entre(7,8.99)){
        console.log('Aprovado!')
    }else if(nota.entre(4,6.99)){
        console.log('Recuperação!')
    }else if(nota.entre(0, 3.99)){
        console.log('Reprovado!')
    }else{
        console.log('Nota inválida!')
    }
    console.log('Fim!')
}
impromirResultado(10)
impromirResultado(8.9)
impromirResultado(6.55)
impromirResultado(2.3)
impromirResultado(-1)
impromirResultado(11)

Switch:
Dentro do case não precisa definir bloco. Pode-se usar a mesma sentença em 2 ou mais cases, sem precisar repetir a sentença
Usa o break para ele não precisar entrar nos outros casos

switch:
const imprimirResultado = function(nota){
    switch (Math.floor(nota)){ // Arredonda para baixo
        case 10: // case 10 e 9, não precisa repetir a sentença
        case 9:
            console.log('Quadro de Honra!')
            break // Para ele não precisar entrar nos outros casos
        case 8: case 7: // Outro modelo
            console.log('Aprovado')
            break
        case 6: case 5: case 4:
            console.log('Recuperação')
            break
        case 3: case 2: case 1: case 0:
            console.log('Reprovado')
            break
        default:
            console.log('Nota inválida')                 
    }
}
imprimirResultado(10)
imprimirResultado(8.9)
imprimirResultado(6.55)
imprimirResultado(2.3)
imprimirResultado(-1)
imprimirResultado(11)

Estruturas de Repetição:
While:
Usado quando não tem uma quantidade exata de repetições

while:
function getInteiroAleatorioEntre(min, max){
    const valor = Math.random() * (max - min) + min
    return Math.floor(valor)
}
let opcao = 0
while(opcao != -1){
    opcao = getInteiroAleatorioEntre(-1, 10)
    console.log(`A opção escolhida foi: ${opcao}`)
}
console.log('Fim')

do while:
function getInteiroAleatorioEntre(min, max){
    const valor = Math.random() * (max - min) + min
    return Math.floor(valor)
}
let opcao //não precisa colocar o valor
do {
    opcao = getInteiroAleatorioEntre(-1, 10)
    console.log(`A opção escolhida foi: ${opcao}`)
} while (opcao != -1)
console.log('Fim')

For:
Primeiro vem a declaração; depois vem a expressão que vai dixer se ele continua ou não no laço; depois vem o incremento
for (let i = 1; i <= 10; i++ ){
    console.log(`Contador = ${i}`)
}

For no array:
const notas = [6.7, 7.4, 9.8, 8.1, 7.7]
for (i = 0; i < notas.length; i++){
    console.log('Notas = '+notas[i])
}

For in:
Vai dar os índices do array
for(índice i em notas)

For in no array:
const notas = [6.7, 7.4, 9.8, 8.1, 7.7]
for(let i in notas) {
    console.log('Índice ' + i + ' recebe o valor ' + notas[i])
}

For in no objeto:
const pessoa = {
    nome: 'Ana',
    sobrenome: 'Silva',
    idade: 29,
    peso: 64
}
for (let atributo in pessoa){
    console.log(`${atributo} = ${pessoa[atributo]}`)
}/* O exemplo acima, de uma forma mais fácil de entender. o for in de objeto funciona da mesma forma que no array
for(let i in pessoa) {
    console.log('atributo ' + i + ' recebe o valor ' + pessoa[i])
}
*/

Break/continue:
Causam desvio de fluxo
Brake influencia no switch, for, while
continue influencia no for, while
devemos evitar o usado 

Break:
const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
for (let x in nums){
    if(x == 5){ //quando for 5 ele para
        break // Não age no if, age no bloco mais próximo dele, no caso o for
    }
    console.log (`${x} = ${nums[x]}`)
}

Continue:
const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
for (y in nums){ 
    if (y==5) continue //ele interrompe essa posição, e pula pra próxima
    console.log(`${y} = ${nums[y]}`)
}

Rótulo: //Não se usa. Pode ser na mesma linha ou na linha de cima
externo: for (a in nums) {
    for (b in nums){
        if( a == 2 && b == 3) break externo
        console.log(`par = ${a},${b}`)
    }
}

Função

Posso guardar o retorno de uma função em uma variável.

Cidadão de Primeira Linha:
Pode tratar função como um dado
Função de alta ordem

função literal:
function fun1() { }

função em variavel:
const fun2 = function () {}

função no array:
const array = [function(a,b) {return a+b}, fun1, fun2]
console.log(array[0](2,3))

Armazenar em um atributo de objeto:
const obj = {}
obj.falar = function(){ return 'OPA'}
console.log(obj.falar())

função como parâmetro de outra função:
function run (fun) {
    fun()
}
run(function ( ){ console.log('Executando...')})

uma função pode retornar/conter uma função:
function soma(a,b){
    return function(c){
        console.log(a+b+c)
    }
} 
soma(2,3)(4) 
ou 
const cincomais = soma(2,3)
cincomais(4)

Parâmetros e retornos são opcionais
Função sem parâmetros
Arguments é um array interno da função, que faz com que não precise de parâmetros

Função com parâmetros variáveis: 
Posso colocar quantos parâmetros eu quiser

Arguments:
function soma(){
    let soma = 0
    for (i in arguments){
        soma += arguments[i]
    }
    return soma
}
console.log(soma())
console.log(soma(1))
console.log(soma(1.1,2.2,3.3))

Parâmetro padrão

Estrategia 1 de gerar valor padrão :
function soma1 (a, b, c) {
    a = a || 1
    b = b || 1
    c = c || 1
    return a + b + c
}
console.log(soma1())
console.log(soma1(), soma1(3))
console.log(soma1(), soma1(3), soma1(1, 2, 3))
console.log(soma1(), soma1(3), soma1(1, 2, 3), soma1(0, 0, 0))

Estrategias 2, 3 e 4: 
function soma2(a, b, c) {
    a = a !== undefined ? a : 1
    b = 1 in arguments ? b : 1 // não esquecer de mudar o índice
    c = isNaN(c) ? 1 : c
    return a+b+c
}
console.log(soma2())
console.log(soma2(), soma2(3))
console.log(soma2(), soma2(3), soma2(1,2,3))
console.log(soma2(), soma2(3), soma2(1,2,3), soma2(0,0,0))

No novo ecmascrypt 2015:
function soma3(a = 1,b = 1, c = 1){
    return a+b+c
}
console.log(soma3())
console.log(soma3(), soma3(3))
console.log(soma3(), soma3(3), soma3(1,2,3))
console.log(soma3(), soma3(3), soma3(1,2,3), soma3(0,0,0))

sorteio

This

O This pode variar:
Em outras linguagens pode ser self 
Varia dependendo da forma que chama a função
Na função arrow o this não varia

This e Bind:
O bind passa um objeto no qual eu quero que seja resolvido o this
.bind(pessoa) //Eu quero que o this aponte para esse objeto

Uso do bind:
const pessoa = {saudacao: 'Bom dia', falar(){console.log(this.saudacao)}}
pessoa.falar()
const falar = pessoa.falar
falar() // conflito entre programação funcional e oo
const falarDePessoa = pessoa.falar.bind(pessoa)

Arrow function

Na Arrow Function, o this não varia. 
Foi criada para reduzir o tamanho e para ter um this que não varia.
Grande vantagem

Sintaxe:
let soma = (a, b) => console.log(a+b)
Armazenar em uma variável (let, var, const), soma recebe parâmetro e retorna (=>) o retorno

Funções anônimas

Função sem nome. Posso usar como parâmetro, armazenar em variável...
const soma = function (x, y) {
    return x + y
}
imprimirResultado(3,4, soma)
imprimirResultado(3, 4, function (x,y){return x-y}) //passando outra operação como parâmetro | Função anonima 
imprimirResultado(3, 4, (x,y) => x*y) // arrow function anonima

Função CallBack

Chamada de volta:
a função será chamada quando um evento novo acontecer

const fabricantes = ['mercedes', 'audi', 'bmw']
function imprimir(nome, indice){
    console.log(`${indice + 1}, ${nome}`)
}
fabricantes.forEach(imprimir) //para cada elemento no array, ele vai chamar essa função

const notas = [7.7, 6.5, 5.2, 8.9, 3.6, 7.1, 9.8]
let notasBaixas = []

sem callback:
for (let i in notas){
    if (notas[i] < 7){
        notasBaixas.push(notas[i])
    }
}
console.log(notasBaixas)

com callback:
notasBaixas = notas.filter(function (nota) { return nota < 7}) // se der true, armazena em notasBaixas
console.log(notasBaixas) 

ou:
const notasMenorQue7 = nota => nota < 7
const notasBaixas2 = notas.filter(notasMenorQue7) // sem precisar criar array notasBaixas2 e armazenando função em variavel
console.log(notasBaixas2)

Funções construtoras:
Usa a função como se fosse classe
O this torna público e o let privado
Precisa instanciar

Tipos de declaração

Eu posso chamar a função, antes de ter criado ela, pois o interpretador do js carraga elas primeiro
Se for uma função literal

console.log(soma(3, 4))
//function declaration
function soma(x, y){
    return x + y
}

Contexto Léxico:
A função carrega consigo, a informação do contexto em que ela foi declarada
A função procura a variável perto de onde ela foi definida

Closures

Basea-se no contexto léxico.
É o escopo criado quando uma função é declarada
Esse escopo permite a função acerrar e manipular variáveis externas à função

Função factory

Função que retorna um objeto. Factory não precisa do this
function criarPessoa(){
    return {
        nome: 'Ana',
        sobrenome: 'Silva'
    }
}
console.log(criarPessoa())

Factory com parâmetro:
function criarProduto (nome, preco){
    return {
        nome, //não precisa ser nome: nome ; pois o nome do atributo é o mesmo nome do valor
        preco,
        desconto: 0.1
    }
}
console.log(criarProduto('Notebook', 2000))

Classe vs Factory

class Pessoa{
    constructor(nome){
        this.nome = nome
    }
    falar(){
        console.log(`Meu nome é ${this.nome}`)
    }
}
const p1 = new Pessoa('João')
p1.falar()

const criarPessoa = nome => {
    return {
        falar: () => console.log(`Meu nome é ${nome}`)
    }
}
const p2 = criarPessoa('joão')
p2.falar()

No browser, o this pode apontar para undefined, mas na factory não

Transformando classe em função:
class Pessoa {
    constructor(nome){
        this.nome = nome
    }
    falar() {
        console.log(`Meu nome é ${this.nome}`)
    }
}
const p1 = new Pessoa("João")
p1.falar()

//vai ser:
function Pessoa2(nome){
    this.nome = nome
    this.falar = function(){
        console.log(`Meu nome é ${this.nome}`)
    }
}
const p2 = new Pessoa2("João")
p2.falar()

IIFE - Imediately invoked function expression

Função auto-invocada
Fugir do escopo global
Função anônima entre parênteses, e foda do ), abrir e fechar, para executar na hora.

(function () {
    console.log("Será executado na hora!")
    console.log("Foge do escopo mais abrangente")
})()

Call & Apply

Chama a função e passa o objeto que vai ser usado como contexto

Call:
console.log(getPreco.call(carro, 0.17, '$')) // Passo direto como parâmetro

Apply:
console.log(getPreco.apply(carro, [0.17, '$'])) // Passa os parâmetros como Array

Orientação a objetos

Adicionando chaves e valores:
const produto = new Object
produto.nome = 'cadeira'
produto['marca do produto'] = 'Genérica'
produto.preco = 220

Deletando chaves e valores:
delete produto.preco
delete produto['Marca do produto']

Exemplo de construção de objetos:
const carro = {
    modelo: 'a4',
    valor: 89000,
    proprietario: {
        nome: 'raul',
        idade: 56,
        endereco: {
            logradouro: 'Rua abc',
            numero: 123
        }
    },
    condutores: [{
        nome: 'Júnior',
        idade: 19
    }, {
        nome: 'Ana',
        idade: 42
    }],
    calcularValorDoSeguro: function(){
        //...
    }
}

Manipulação:
carro.proprietario.endereco.numero = 1000
delete carro.condutores
delete carro.proprietario.endereco
delete carro.calcularValorDoSeguro

Formas de criação de objetos

Usando a notação literal:
const obj1 = {}
console.log(obj1)

Object em js:
const obj2 = new Object
console.log(obj2)

Funções construtoras (this publico):
function Produto(nome, preco, desc){
    this.nome = nome
    this.getPrecoComDesconto = () => {
        return preco * ( 1- desc )
    }
}
const p1 = new Produto('Caneta', 7.99, 0.15)
const p2 = new Produto('Notebook', 2998.99, 0.25)
console.log(p1.getPrecoComDesconto(), p2.getPrecoComDesconto())

Funçaõ factory:
function criarFuncionario(nome, salarioBase, faltas){
    return{
        nome,
        salarioBase,
        faltas,
        getSalario(){
            return (salarioBase / 30) * (30 - faltas)
        }
    }
}
const f1 = criarFuncionario('João', 7980, 4)
const f2 = criarFuncionario('Maria', 11400, 1)
console.log(f1.getSalario(), f2.getSalario())

Object.create:
const filha = Object.create(null)
filha.nome = 'Ana'
console.log(filha)

Uma função famosa que retorna um objeto:
const fromJSON = JSON.parse('{"info":"Sou um JSON"}')
console.log(fromJSON.info)

Objeto constante:
Object.freeze(pessoa) //Congela o objeto
const pessoaConstante = Object.freeze({nome: 'João'}) //Congela o objeto

Getters & Setters

const sequencia = {
    _valor: 1, //Mostra que vai ser uma variável privada - Mas é só na sintaxe, não muda a semântica
    get valor(){
        return this._valor++
    },
    set valor(valor){
        if (valor > this._valor){
            this._valor = valor
        }
    }
}
console.log(sequencia.valor, sequencia.valor)//get
sequencia.valor = 1000 //set
console.log(sequencia.valor, sequencia.valor)

Funções importantes de Objeto

console.log(Object.keys(objeto))//retorna só as chaves
console.log(Object.values(objeto))//Retorna só os valores
console.log(Object.entries(pessoa))//Cria um sub array com chave/valor

Mostrando só o valor do objeto:
const obj = {nome: 'caina', sobrenome: 'micael'}
for (let [chave, valor] of Object.entries(obj)){
    console.log(valor)
}

Mostrando só a chave do objeto:
const obj2 = {nome: 'caina', sobrenome: 'micael'}
for (let [chave, valor] of Object.entries(obj)){
    console.log(chave)
}

Gambiarra 1(pessoal):
function media(alunos){
    const notas = []
    const notasSomadas = []
    const medias = []
    let i = 0
    let c = 0
    Object.entries(alunos).forEach(array => notas.push(array[1]))
    for (let nota of notas){
        nota.reduce((a,b) => notasSomadas[i] = a + b)
        i++
    }
    for (let nota of notasSomadas){
        medias[c] = nota/ notas[c].length
        c++
    }
    return medias
}
const alunos = {Joao: [10, 10, 10, 10], Marina: [8, 8, 8, 8], carla: [7, 7, 7, 7]}
console.log(media(alunos))

Desmenbrando objeto:
function media(alunos){
    const mapeado = []
    Object.entries(alunos).map(array => {
        return mapeado.push({nome: array[0], nota: array[1]})
    })
    return mapeado
}
const alunos = {Joao: [10, 10, 10, 10], Marina: [8, 8, 8, 8], carla: [7, 7, 7, 7]}
console.log(media(alunos))

Ex2:
const chineses = f => f.pais === 'China'
const mulheres = f => f.genero === 'F'
const menorSalario = (funcionario, funcionarioAtual) => {
    return funcionario.salario < funcionarioAtual ? funcionario : funcionarioAtual
}

axios.get(url).then(response => {
    const funcionarios = response.data

    const func = funcionarios
        .filter(chineses)
        .filter(mulheres)
        .reduce(menorSalario)

    console.log(func)
})


Destructuring:
Object.entries(pessoa).forEach(e => {
    console.log(`${e[0]}: ${e[1]}`)
}) 
//ou
Object.entries(pessoa).forEach(([chave, valor]) => {
    console.log(`${chave}: ${valor}`)
})

Definindo Propriedade:
Object.defineProperty(pessoa, 'dataNascimento',{
    enumerable: true,
    writable: false,
    value: '01/01/2001'
})
console.log(pessoa.dataNascimento) //adiciona dataNascimento ao objeto

Concatenar objetos para objeto de destino:
const dest = {a: 1}
const o1 = {b: 2}
const o2 = {c: 3, a: 4} //sobescreve o a para 4
const obj = Object.assign(dest,o1, o2)

Herança

Procura o pai:
const ferrari = {
    modelo: 'f40',
    velMax: 324
}
console.log(ferrari.__proto__) //atributo padrão 
console.log(ferrari.__proto__ === Object.prototype)//true

Cadeia de protótipos (Aceita Sobrescrever):
Object.prototype.attr0 = '0'
const avo = {attr1: 'A'} // o __proto__ dele é o Object.prototipe
const pai = {__proto__: avo, attr2: 'B', attr3: 'Fe'}
const filho = {__proto__:pai, attr3: 'C'}
console.log(filho.attr1)
console.log(filho.attr0, filho.attr1, filho.attr2, filho.attr3) //vai mostrar o attr3 de filho (Shadowing)

Super:
const carro = {
    velAtual: 0,
    velMax: 200,
    acelerarMais(delta){
        if(this.velAtual + delta <= this.velMax){
            this.velAtual += delta
        } else {
            this.velAtual = this.velMax
        }
    },
    status(){
        return `${this.velAtual}KM/h de ${this.velMax}KM/h`
    }
}
const ferrari = {
    modelo: 'f40',
    velMax: 324 //Shadowing
}
const volvo = {
    modelo: v40,
    status() {
        return `${this.modelo}: ${super.status()} ` //o super serve para chamar o objeto da herança. não o this
    }
}

Setando protótipo:
Object.setPrototypeOf(ferrari, carro) // Ferrari vai ter como protótipo carro
Object.setPrototypeOf(volvo, carro) // Volvo vai ter como protótipo carro

Object.create já cria passando o prototipo:
const pai = {nome: 'Pedro', corCabelo: 'Preto'}
const filha1 = Object.create(pai)
filha1.nome = 'Ana'
console.log(filha1.corCabelo)
const filha2 = Object.create(pai, {
    nome: {value: 'Bia', writable: false, enumerable: true}
})
console.log(filha2.nome)
console.log(`${filha2.nome} tem cabelo ${filha2.corCabelo}`)
for(let key in filha2){
    filha2.hasOwnProperty(key) ?
        console.log(key) : console.log('Por herança' + key)
}

Objetos criados a partir de uma função construtora, apontam para o mesmo protótipo:
function MeuObjeto(){ }
console.log(MeuObjeto.prototype)

const obj1 = new MeuObjeto
const obj2 = new MeuObjeto

console.log(obj1.__proto__ === obj2.__proto__)
console.log(MeuObjeto.prototype === obj1.__proto__)

MeuObjeto.prototype.nome = 'Anônimo'
MeuObjeto.prototype.falar = function () {
    console.log(`Olá, meu nome é ${this.nome}!`)
}

obj1.falar()
obj2.nome = 'Rafael'
obj2.falar()
const obj3 = {}
obj3.__proto__ = MeuObjeto.prototype
obj3.nome = 'Obj3'
obj3.falar()

Acertivas:
console.log((new MeuObjeto).__proto__ === MeuObjeto.prototype)
console.log(MeuObjeto.__proto__ === Function.prototype)
console.log(Function.prototype.__proto__ === Object.prototype)
console.log(Object.prototype.__proto__ === null)

Mais sobre o prototype:
console.log(typeof String)
console.log(typeof Array)
console.log(typeof Object)

String.prototype.reverse = function () {
    return this.split('').reverse().join('')
    //o split separa as letras e coloca num array | o reverse reverte o array | o join junta as letras do array e volta a ser str
}
console.log('Escola Cod3r'.reverse())

Array.prototype.first = function (){
    return this[0]
}

console.log([1, 2, 3, 4, 5].first())

Simulando o new:
function novo(f, ...params){
    const obj = {}
    obj.__proto__ = f.prototype
    f.apply(obj, params)
    return obj
}
const aula3 = novo(Aula, 'Bem vindo', 123)

Object.preventExtensions:
Bloqueia add atributos, mas pode remover
const produto = Object.preventExtensions({
    nome: 'Qualquer',
    preco: 1.99,
    tag: 'Promoção'
})
console.log("Extensivel: ", Object.isExtensible(produto))
produto.nome = 'borracha'
delete produto.tag
console.log(produto)

Object.seal - Selar: 
Não pode adicionar nem remover, mas posso mudar os valores
const pessoa = {
    nome: 'Juliana',
    idade: 35
}
Object.seal(pessoa) 
console.log('Selado:', Object.isSealed(pessoa))

JSON:
Arquivo de texto, interpretado em todas as linguagens

Transformando Objeto em JSON:
const obj = {a: 1, b: 2, c: 3, soma(){ return a + b + c}}
console.log(JSON.stringify(obj))

JSON em Objeto:
console.log(JSON.parse('{"a": 1, "b": 2, "c": 3}'))
//Observar onde é aspas ' e aspas "
console.log(JSON.parse('{"a": "1", "b": "string", "c": true, "d": {}, "e":[]}'))

Classes e Agregação:
class Lancamento {
    constructor(nome = 'Genérico', valor = 0){
        this.nome = nome
        this.valor = valor
    }
}

class CicloFinanceiro {
    constructor(mes, ano){
        this.mes = mes
        this.ano = ano
        this.lancamentos = []
    }
    addLancamentos(...lancamentos){
        lancamentos.forEach(l => this.lancamentos.push(l))
    }
    sumario(){
        let valorConsolidado = 0
        this.lancamentos.forEach(l => {
            valorConsolidado += l.valor
        })
        return valorConsolidado
    }
}
const salario = new Lancamento('Salario', 45000)
const contaDeLuz = new Lancamento('luz', -220)
const contas = new CicloFinanceiro(6, 2018)
contas.addLancamentos(salario, contaDeLuz)

console.log(contas.sumario())

Herança em classes:
class Avo {
    constructor(sobrenome){
        this.sobrenome = sobrenome
    }
}
class Pai extends Avo{
    constructor(sobrenome, profissao = 'Professor'){
        super(sobrenome)
        this.profissao = profissao
    }
}
class Filho extends Pai {
    constructor(){
        super('Silva') // em todas as classes vai ser silva
    }
}
const filho = new Filho
console.log(filho)

Array

No js, o array é um objeto, que organiza os neus dados através de um índice
Ele é dinâmico e posso colocar vários tipos
É bom trabalhar com dados do mesmo tipo no array

Forma instanciada de array:
let aprovados = new Array('Bia', 'Carlos', 'Ana')
console.log(aprovados)

Forma literal de array:
aprovados = ['Bia', 'Carlos', 'Ana']
console.log(aprovados[0])
console.log(aprovados[1])

Adicionando valores:
aprovados.push('Abia')//adição

Remover o último valor:
aprovados.pop()

Remover o primeiro elemento:
aprovados.shift('nome')

Substituindo valores:
aprovados[3] = 'paulo' //Substituição, mas pode usar essa forma para add

Ordenar por ordem alfabética:
aprovados.sort()

Excluir:
delete aprovados[1]//deixa undefined, não reordena

Splice:
aprovados.splice(1, 1) //a partir do indice 1, excluir 1(ou +) elemento. se for 1, exclui o do indice e reordena
aprovados.splice(1, 2, 'addelemento1', 'addelemento2')//a partir do indice 1, dps da exclusão, ele pode adicionar também
aprovados.splice(1, 0, 'addelemento1', 'addelemento2')//a partir do indice 1,não há exclusão, ele pode adicionar também

Adicionar elemento no primeiro indice (0):
aprovados.unshift('nome')

Novo array:
const algunsPilotos = pilotos.slice(2) // cria um novo array a partir do indice 2
const algunsPilotos2 = pilotos.slice(1, 4) // do 1 ao 4, só que o 4 não entra. 4-1

Simulando array com objetos:
const quaseArray = {0: 'Rafael', 1: 'Ana', 2: 'Bia'}
console.log(quaseArray)
Object.defineProperty(quaseArray, 'toString', {
    value: function() { return Object.values(this)},
    enumerable: false
})
console.log(quaseArray[0])

forEach

Uma função, que dentro tem o laço for. Quando achar o 1º elemento, ele entra na callback
e faz o queos parâmetros da callBack  pedem

a ordem dos parâmetros de uma callBack no forEach:
1º Nome,
2º Índice
3º Array ou a estrutura que está trabalhando, ex: Objeto

array de aprovados:
aprovados.forEach(function (nome, indice, array) { //o índice é sempre o segundo parâmetro
    console.log(`${indice + 1} ${nome}`)
    console.log(array)
})

forEach com array function:
aprovados.forEach(nome => console.log(nome))

Função na variável:
const exibirAprovados = aprovados => console.log(aprovados)
aprovados.forEach(exibirAprovados)

Criando nosso forEach:
Array.prototype.forEach2 = function(callback){
    for (let i = 0; i < this.length; i++){
        callback(this[1], i, this)
    }
}

map

Serve para tranformação do array
Não modifica o array atual
Cria um array do mesmo tamanho, com os dados transformados

Mapeando para criar um novo array, com os valores * 2:
const nums = [1 ,2, 3, 4, 5]
// for com proposito
let resultado = nums.map(function(e){
    return e*2
})

map "recursivo":
const some10 = e => e + 10
const triplo = e => e * 3
const paraDinheiro = e => `R$ ${parseFloat(e).toFixed(2).replace('.',',')}`
resultado = nums.map(soma10).map(triplo).map(paraDinheiro)

Json para objeto, e colher um atributo desse objeto:
const carrinho = [
    '{"nome": "Borracha", "preco": 3.45}',
    '{"nome": "caderno", "preco": 13.90}',
    '{"nome": "Kit de lápis", "preco": 41.42}',
    '{"nome": "caneta", "preco": 7.50}'
]
const paraObjeto = json => JSON.parse(json)
const apenasPreco = produto => produto.preco
const resultado = carrinho.map(paraObjeto).map(apenasPreco)
console.log(resultado)

Criando nosso próprio map:
Array.prototype.map2 = function(callback){
    const newArray = []
    for(let i = 0; i < this.length; i++){
        newArray.push(callback(this[i], i, this))
    }
    return newArray
}

filter

Cria um novo array baseado no filtro

filtro de preco:
const produtos = [
    {nome: 'Notebook', preco: 2499, fragil: true},
    {nome: 'Ipad pro', preco: 4199, fragil: true},
    {nome: 'Copo de vidro', preco: 12.49, fragil: true},
    {nome: 'Copo de plastico', preco: 18.99, fragil: false}
]
console.log(produtos.filter(function (p) {
    return p.preco > 2500 // se for return false, nenhum elemento passa para o novo array
}))

exemplo 2:
const filtrarNumeros = array => {
    return array.filter(item => typeof item === 'number')
}

Criando nosso próprio filter:
Array.prototype.filter2 = function(callback){
    const newArray = []
    for(let i = 0; i < this.length; i++){
        if (callback(this[i], i, this)){
            newArray.push(this[i])
        }
    }
}

Reduce

Agrega valores
Acululador é o primeiro elemento e atual é o segundo, e na proxima repetição, 
o acumulador vai ser a junção do indice 0 + indice 1, e o atual vai ser o indice 2
e assim por diante

Uso do reduce como soma geral:
const alunos = [
    {nome: 'João', nota: 7.3, bolsista: false}, 
    {nome: 'Maria', nota: 9.2, bolsista: true},
    {nome: 'Pedro', nota: 9.8, bolsista: false},
    {nome: 'ana', nota: 8.7, bolsista: true}
]
const resultado = alunos.map(a => a.nota).reduce(function(acumulador, atual){
    console.log(acumulador, atual)
    return acumulador + atual
})
/*
7.3 9.2
16.5 9.8
26.3 8.7 */

Ja´passando um valor inicial:
const resultado = alunos.map(a => a.nota).reduce(function(acumulador, atual){
    console.log(acumulador, atual)
    return acumulador + atual
},10)// esse 10 é para ja começar com 10 - 10 é o acumulador

Para ver se todos os valores dos atributos são iguais (true ou false):
const alunos = [
    {nome: 'João', nota: 7.3, bolsista: true}, 
    {nome: 'Maria', nota: 9.2, bolsista: true},
    {nome: 'Pedro', nota: 9.8, bolsista: true},
    {nome: 'ana', nota: 8.7, bolsista: true}
]
const todosBolsistas = (resultado, bolsista) => resultado && bolsista
console.log('Todos são bolsistas? ' + alunos.map(a => a.bolsista).reduce(todosBolsistas))

Para ver a quantidade de true ou false:
const alunos = [
    {nome: 'João', nota: 7.3, bolsista: true}, 
    {nome: 'Maria', nota: 9.2, bolsista: true},
    {nome: 'Pedro', nota: 9.8, bolsista: true},
    {nome: 'ana', nota: 8.7, bolsista: true}
]
const algumBolsista = (resultado, bolsista) => resultado+bolsista //resultado || bolsista para saber se tem 1 bolsista
console.log('Quantidade de alunos bolsistas: ' + alunos.map(a => a.bolsista).reduce(algumBolsista))

Criando nosso reduce:
Array.prototype.reduce2 = function(callback, valorInicial){
    const indiceInicial = valorInicial ? 0 : 1
    let acumulador = valorInicial || this[0]
    for (let i = indiceInicial; i < this.length; i++){
        acumulador = callback(acumulador, this[i], i, this)
    }
    return acumulador
}
const soma = (total, valor) => total + valor
const nums = [1,2,3,4,5,6]
console.log(nums.reduce2(soma, 21))

Imperativo VS Declarativo

const alunos = [
    {nome: 'João', nota: 7.9},
    {nome: 'Maria', nota: 9.2}
]

Imperativo:
Serve para ensinar passo a passo de como fazer - Foca no que será feito - Os detalhes importam mais
let total1 = 0
for (let i = 0; i < alunos.length; i++){
    total1 += alunos[i].nota
}
console.log(total1 / alunos.length)

Declarativa:
As coisas são feitas internamente - Foca no resultado final, o que tem que ser feito - O resultado é o que importa
const getNota = aluno => aluno.nota
const soma = (total, atual) => total + atual 
const total2 = alunos.map(getNota).reduce(soma)
console.log(total2 / alunos.length)

Concat 

Concatenar vários arrays em um novo array

Concatenando Arrays:
const filhas  = ['Valeskah', 'Cibalena']
const filhos  = ['Washington','Wescley']
const todos = filhas.concat(filhos)
console.log(todos)

Concatenar e adicionar:
const todos = filhas.concat(filhos, 'Fulano')

FlatMap

Junta matrizes

Criando um flatMap: 
const escola = [{
    nome: 'turma m1',
    alunos: [{
        nome: 'Gusttavo',
        nota: 8.1
    },{
        nome: 'ana',
        nota: 9.3
    }]
}, {
    nome: 'Turma m2',
    alunos: [{
        nome: 'Rebeca',
        nota: 8.9
    }, {
        nome: 'Roberto',
        nota: 7.3
    }]
}]
console.log(escola)
const getNotaDoAluno = aluno => aluno.nota
const getNotasDaTurma = turma => turma.alunos.map(getNotaDoAluno)
const notas1 = escola.map(getNotasDaTurma)
console.log(notas1)
Array.prototype,flatMap = function(callback){
    return Array.prototype.concat.apply([], this.map(callback))
}
const todasAsNotas = escola.flatMap(getNotasDaTurma)
console.log(todasAsNotas)

Módulos Node.JS

Muda a forma de utilização se for front/back - end
No back, é uma preocupação menor, já que não terá as traduções para o browser entender
No node, um arquivo está dentro do módulo
Aplicação Beck-end em pastas e arquivos, no módulo
O módulo não deixa disponível as informações. Para torna-lo público, presisa-se de uma exportação
Padrão CommonJS e o padrão do Ecmascrypt 2015

Para exportar:
this.ola = 'Fala Pessoal' //Obj
exports.bemVindo = 'Bem vindo ao node' //Obj
module.exports.ateLogo = 'Até o próximo exemplo' //Forma mais utilizada

Ex module.exports:
module.exports = {
    bomDia: 'Bom dia',
    boaNoite() {
        return 'Boa noite'
    }
}

Importando módulos - caminho relativo (se estiver nos meus projetos):
const moduloA = require('./moduloA') //caminho relativo
const moduloB = require('./moduloB')
console.log(moduloA.ola)
console.log(moduloA.bemVindo)
console.log(moduloA.ateLogo)
console.log(moduloA)
console.log(moduloB.bomDia)
console.log(moduloB.boaNoite())

Usando módulos de terceiros:
no terminal: npm i lodash
const _ = require('lodash') // como ta usando o lodash, o nome é _ e não precisa de caminho
setInterval(() => console.log(_.random(1,1000)),2000) // Sorteio usando lodash

require:
const moduloA = require('../../moduloA') // o .. sai das subpastas

se eu criar na pasta node modules:
const saudacao = require('saudacao')

Local host usando múdulo no node:
const http = require('http')
http.createServer((req,resp) => {
    resp.write('Bom dia')
    resp.end()
}).listem(8080)

Arquivo packag.json

Descreve todo o projeto

Criando:
npo init //Para eu responder as perguntas
npo init -y//Para responder as perguntas com sim

Colocando dependências:
npm i --save axios

Sinais:
"axios": "^0.27.2"
O ^ quer dizer q vai atualizar, mas não vai pra 1.0
O ~ quer dizer q pode ir até 0.27.9, e não 0.28
Sem sinal limita só até esta versão

Axios:
Cliente http - Obtem informações remotas

const url = 'http://files.cod3r.com.br/curso-js/funcionarios.json'
const axios = require('axios') //cliente http - Obtem informações remotas

uso:
axios.get(url).then(response => {
    const funcionarios = response.data
    console.log(funcionarios)
}) //pega a url e extrai os funcionarios

Instância unica vs nova instância:
Uma instância unica, se tivr 2 variáveis atribuidas, muda o valor das duas. Na nova, só muda de uma

Objeto global:
global.MinhaApp = Object.freeze({
    saudacao(){
        return 'Estou em todos os lugares'
    },
    nome: 'Sistema legal'
})//em outra aba
require('./global')
console.log(MinhaApp.saudacao())

MinhaApp.nome = 'Eita!'
console.log(MinhaApp.nome)

Entendendo o this:
Dentro da função, o this não aponta para exports; mas fora aponta
Dentro da função ele aponta para global. Fora, não
console.log(this === global)
console.log(this === module)
console.log(this === module.exports)
console.log(this === exports)
function logThis (){
    console.log('Dentro da função')
    console.log(this === exports)
    console.log(this === module.exports)
    console.log(this === global)
}

logThis()

Passando parâmetros entre módulos

Depois do require, eu posso passar os parâmetros da função, eu outro parentese

Exemplo:
module.exports = function(...nomes){
    return nomes.map(nome => 'Boa semana ' + nome + '!')
}//em outra aba
const saudacoes = require('./passandoParametros')('Ana','Lucas','João')

Script no package.json:
 "scripts": {
    "start": "nodemon",
    "dev": "nodemon",

No terminal para executar:
npm start //Ja tem nomenclatura padrão ex test, restart, start
npm run dev

Lendo arquivos node

Para leitura, tenho que criar um arquivo json com as informações:
{
    "db": {
        "host": "localhost",
        "porta": 5432,
        "user": "usuário",
        "pass": 123456
    }
}

Tenho que importar um módulo fs (File System):
const fs = require('fs')//ja vem instalado no node
const caminho = __dirname + '/arquivo.json' // mostra o caminho

__dirname:
Representa o diretório atual
 __dirname + '/arquivo.json'

Sincrono: //ja usando o require do ex anteriores
const conteudo = fs.readFileSync(caminho, 'utf-8')
console.log(conteudo) // Não é muito viável, pois tem q esperar carregar

Assincrono:
fs.readFile(caminho, 'utf-8', (err, conteudo) => {
    const config = JSON.parse(conteudo)
    console.log(`${config.db.host}:${config.db.port}`)
})
//Ou se for json
const config = require('./arquivo.json')
console.log(config.db)

Lendo arquivos de uma pasta:
fs.readdir(__dirname, (err, conteudo) => {
    console.log('conteudo da pasta')
    console.log(conteudo)
})

Escrevendo arquivos

exemplo:
const fs = require('fs')

const produto = {
    nome: 'celular',
    preco: 1249.99,
    desconto: 0.15
}
                    diretorio                transformar em json          tratar erro
fs.writeFile(__dirname + '/arquivoGerado.json', JSON.stringify(produto), err => {
    console.log(err || 'Arquivo salvo!')
})

conceito de Framework Web

É algo que estrutura a aplicação
É um arcabolço para desenvolver a aplicação seguindo os preceitos que ele estabelece
Vai organizar a aplicação inteira

Temos frameworks front-end e back-end
Eles dão a estrutura básica (de base) para a aplicação, total ou parcial
Pode-se usar um conjunto de frameworks 

Padrão Chain of Responsability (padrão Middleware)

Consiste em reúso, separando o processo em passos, sem seguir uma sequência específica
Request & Response (requisição e respostas)

Uso:
const passo1 = (ctx, next) => {
    ctx.valor1 = 'mid1'
    next()
}
const passo2 = (ctx, next) => {
    ctx.valor2 = 'mid2'
    next()
}
const passo3 = ctx => ctx.valor3 = 'mid3' 
const exec = (ctx, ...middlewares) => {
    const execPasso = indice => {
        middlewares && indice < middlewares.length &&
            middlewares[indice](ctx, () => execPasso(indice + 1))
    }
    execPasso(0)
}
const ctx = {}
exec(ctx, passo1, passo2, passo3) //Pode mudar a ordem
console.log(ctx)

Express JS

Instalando o Postman
Uma forma de fazer requisições de forma flexível
https://www.postman.com/downloads/?utm_source=postman-home

Projeto: API com Express

Na pasta do projeto, iniciar o package.json (npm init -y)
e instalar o express (npm i --save express@4.16.2 -E)
criar dentro da pasta do projeto a pasta src e dentro da src criar o arquivo servidor.js

uso:
const porta = 3003
const express = require('express')
const app = express()
app.get('/produtos',(req, res, next) => {
    res.send({nome: 'Notebook', preco: 123.45 }) //Converter para JSON
})
app.listen(porta, () => {
    console.log('Servidor executando na variável porta ' + porta)
})

Temporizadores:
npm i node-schedule
//const tarefa1 = schedule.scheduleJob('*/5 * 12 * * 2')
                               5 em 5 seg   qq minuto  12 horas   ignora o mes  ignora o dia do mes  terça feira
o */ é para dizer que é um loop de 5 em 5 seg

Uso:
const tarefa1 = schedule.scheduleJob('*/5 * 10 * * 3',function(){
    console.log('Executando tarefa 1: ', new Date().getSeconds())
})

Parando temporizador:
setTimeout(function(){
    tarefa1.cancel()
    console.log('Cancelando tarefa! ')
}, 20000) // depois de 20segs

Regra:
const regra = new schedule.RecurrenceRule()
regra.dayOfWeek = ( new schedule.Range(1,5)) // de segunda a sexta
regra.hour = 10
regra.second = 30

Usando regras: 
const tarefa2 = schedule.scheduleJob(regra, function(){
    console.log('Executando tarefa 2: ', new Date().getSeconds())
})

Process: Entrada e Saída Padrão 

node EntradaESaida.js -a //a flag que a gente criou

Pegando parâmetros através da entrada no terminal:
const anonimo = process.argv.indexOf('-a') !== -1
console.log(anonimo)
if(anonimo){
    process.stdout.write("Fala Anônimo!\n") //escrita de dados
} else {
    process.stdout.write('Informe o seu nome: ')
    process.stdin.on('data', data => { //entrada de dados
        const nome = data.toString().replace('\n','')
        process.stdout.write(` fala ${nome}!\n`)
        process.exit()
    })
}

Operador Rest/Spread

Uso:
//rest(juntar)spread(espalhar)
//usar rest com parametro de função
//Usar spread com objeto
const funcionario = {nome: 'maria', salario: 12348.99}
const clone = {ativo: true, ...funcionario}
console.log(clone)
//Usar spread com array
const grupoA = ['João', 'Pedro', 'Glória']
const grupoFinal = ['Maria', ...grupoA, 'Rafaela' ]
console.log(grupoFinal)

Tagged Template

Tagged templates - processa o template string dentro de uma função
Vaai criar um array sem os valores da concatenação e outro só com os valores da concatenação

uso: 
function tag (partes, ...valores){
    console.log(partes)
    console.log(valores)
    return 'Outra string'
} 
const aluno = 'Gui'
const situacao = 'Aprovado'
console.log(tag`${aluno} está ${situacao}`)

Resulta em:
[ '', ' está ', '' ]
[ 'Gui', 'Aprovado' ]
Outra string

Set 

//Não aceita repetição e não é indexado
const times = new Set()
times.add('Vasco')
times.add('São paulo').add('palmeiras').add('corithians')
times.add('Flamengo')
times.add('Vasco')//adiciona
console.log(times.has('Vasco'))//tem vasco?

For of

O for in intera na forma de indica, ja o for of na forma de valores

uso:
for (let letra of 'Cod3r'){
    console.log(letra)
}

Desmembrando (destructuring) com o for of:
for (let assunto of assuntosMap){
    console.log(assunto)
}
for (let chave of assuntosMap.keys()){
    console.log(chave)
}
for (let valor of assuntosMap.values()){
    console.log(valor)
}
for (let [ch, v1] of assuntosMap.entries()){
    console.log(ch, v1)
}

Promise

representa uma operação assíncrona 

ex:
function falarDepoisDe (segundos, frase) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(frase)
        }, segundos * 1000)
    })
}
falarDepoisDe(3, 'Que legal')
    .then(frase => frase.concat('?!?'))
    .then(outraFrase => console.log(outraFrase)) 










HTML (Linguagem de Marcação de Hiper-Texto)

Anatomia da tag (Não é Sensitive Case):

<tag>
    <!--comentário: esse é o modelo de abertura e fechamento de tag com corpo -->
</tag>

em tags sem corpo, não precisa de fechamento
<tag>
ou desse jeito
<tag />
Pode-se criar tags personalizadas 

exemplos de tags sem corpo:
<meta>
<br>
<input/>

Parâmetros:
<tag param1= "valor" param1= 'valor'>
    <!-- Corpo da Tag-->
</tag>
Existem parâmetros padronizados

Anatomia de uma página HTML (Tudo tem a sua semântica):
<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Anatomia HTML</title> <!-- Unica coisa do head que é visivel-->
    </head>
    <body>
        <header>
            <h1>Exercícios HTML</h1>
        </header> <!-- Cabeçalho da pagina -->
        <nav>
            <a href="/">Navegação 1</a>
        </nav>  <!-- links -->
        <section id = 'conteudo'>
            conteúdo
        </section> <!-- conteúdo -->
        <aside>
            Lateral
        </aside> <!-- algo na lateral -->
        <footer>
            rodapé
        </footer> <!-- Rodapé -->
    </body>
</html>

Um pouco de CSS:

O id da Tag é individual
A class é mais abrangente

<span id="textoPrincipal">Texto 1</span><br>
<span class="fundoVermelho negrito">Texto 2</span><br> <!-- Nesse caso, são duas classes -->
<span class="fundoVermelho" wm-atrib>Texto 3</span> /* Cria um atributo [usa para pegar]*/

No head:
<style>
    h1 {
        /* display: none;   todo h1 vai sumir */
        font-size: 20px;
    }

    #textoPrincipal{ /*Pegando pelo id*/
        font-size: 40px;
        font-weight: bold;
        background-color: #444;
        color: #fff;
        margin-bottom: 50px;
    }

    .fundoVermelho { /*o ponto na frente diz que é uma classe*/
        background-color: #C00;
    }

    .negrito {
        font-weight: bold;
    }
</style>

Caso use o css em putra aba, é só no head colocar o link
 <link rel="stylesheet" href="poucoDeCss.css"> /*O href é o nome do arquivo css*/

 Pode usar o css direto na tag
 <span id="textoPrincipal" style ="display: none;">Texto 1</span><br> /*Não recomendado*/

 Linkando páginas html (no body):
 <header>
        <h1>Exercícios HTML</h1>
    </header>
    <nav>
        <a href="exercicios/teste.html"> Nome do link </a>
    </nav>

Pegando textos de outra pagina e jogando no conteudo da pagina inicial:
<script>
    document.querySelectorAll('a').forEach(link => {
    const conteudo = document.getElementById("conteudo")

        link.onclick = function (e) {
            e.preventDefault()
            fetch(link.href)
                .then(resp => resp.text())
                .then(html => conteudo.innerHTML = html)
        }
    })
</script>